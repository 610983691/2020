###理论和原理
1.主要参考《并发编程的艺术》

美团技术团队：

[https://tech.meituan.com/2018/11/15/java-lock.html](https://tech.meituan.com/2018/11/15/java-lock.html)

2.内存屏障：
	是一组处理器指令，用于实现对内存操作的顺序限制。

volatile：



> 查看volatile字节码，在volatile修饰的变量前会有LOCK前缀，这个LOCK会引起处理器将volatile修饰的变量回写到内存中。同时，处理器回写内存会让其他处理器中volatile修饰的变量的值失效。

这两条指令的特性就是常见的另外一种描述，会禁止指令重拍和让缓存失效。让处理器每次都从内存中重新加载值而不是使用当前值。

3.使用jclasslib查看字节码

[https://www.jianshu.com/p/252f381a6bc4](https://www.jianshu.com/p/252f381a6bc4)

4.synchronized 锁分析

monitorenter，monitorexi

偏向锁：大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。
> 当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需
要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则
使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。


###实践